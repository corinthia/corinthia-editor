<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/html4/loose.dtd">
<!-- Copyright (c) 2011-2012 UX Productivity Pty Ltd. All rights reserved. -->
<html>
<head>
<link rel="stylesheet" type="text/css" href="TreeView.css" />
<style type="text/css">

body { -webkit-user-select: none }

</style>
<script type="text/javascript" src="../DOM.js"></script>
<script type="text/javascript" src="../UndoManager.js"></script>
<script type="text/javascript" src="../NodeSet.js"></script>
<script type="text/javascript" src="../Position.js"></script>
<script type="text/javascript" src="../Range.js"></script>
<script type="text/javascript" src="../traversal.js"></script>
<script type="text/javascript" src="../util.js"></script>

<script type="text/javascript" src="TreeView.js"></script>
<script type="text/javascript" src="StepController.js"></script>
<script type="text/javascript" src="Slider.js"></script>
<script type="text/javascript" src="BoundingPolygons.js"></script>
<script type="text/javascript">

// http://station.woj.com/2010/02/javascript-random-seed.html
//var randomSeed = new Date().getTime();
//var randomSeed = 1328615295137;
//var randomSeed = 1328725991396;
var randomSeed = 1328744506051;
debug("randomSeed = "+randomSeed);
function random()
{
    randomSeed = (randomSeed*9301+49297) % 233280;
    return randomSeed/(233280.0);
}

var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
var SVG_VERSION = "1.1";

function debug(str)
{
    console.log(str);
}

function buildTree(doc,parent,depth,nchildren)
{
    if (depth > 0) {
        var count = Math.floor(nchildren*random());
        for (var i = 0; i < count; i++) {

            UndoManager.newGroup();
            var child = DOM.createElement(doc,"DIV");
            child.setAttribute("class","treenode");
            DOM.appendChild(parent,child);


            buildTree(doc,child,depth-1,nchildren);
        }
    }
}

function removeTextNodes(node)
{
    var next;
    for (var child = node.firstChild; child != null; child = next) {
        next = child.nextSibling;
        if (child.nodeType == Node.TEXT_NODE) {
            DOM.deleteNode(child);
        }
        else {
            removeTextNodes(child);
        }
    }
}

function programmaticTree()
{
    var root = DOM.createElement(document,"DIV");
    root.style.display = "none";
    DOM.appendChild(document.body,root);
    DOM.addUndoListeners(root);
    UndoManager.group(buildTree,document,root,6,4);
    return root;
}

var dragging = false;
var state = { startPosition: null, endPosition: null, beginning: null, middle: null, end: null };
var treeView = null;
var range = null;

function addNodesToSetRecursive(set,node)
{
    set.add(node);
    for (var child = node.firstChild; child != null; child = child.nextSibling)
        addNodesToSetRecursive(set,child);
}

function updateForPosition(position)
{
    if (range == null) {
        range = new Range(position.node,position.offset,position.node,position.offset);
    }
    else {
        range = new Range(range.start.node,range.start.offset,
                                position.node,position.offset);
    }
    state.startPosition = range.start;
    state.endPosition = range.end;
    var info = new Object();
    var nodes = range.getOutermostNodes(false,info);

    var beginning = new NodeSet();
    var middle = new NodeSet();
    var end = new NodeSet();

    info.beginning.forEach(function(node) { addNodesToSetRecursive(beginning,node); });
    info.middle.forEach(function(node) { addNodesToSetRecursive(middle,node); });
    info.end.forEach(function(node) { addNodesToSetRecursive(end,node); });

    state.beginning = beginning;
    state.middle = middle;
    state.end = end;

    treeView.update();
}

function updateForNode(node)
{
    var offset = DOM.nodeOffset(node);
    updateForPosition(new Position(node.parentNode,offset));
}

function mouseDownPosition(position)
{
    dragging = true;
    range = null;
    updateForPosition(position);
}

function mouseUpPosition(position)
{
    dragging = false;
}

function mouseOverPosition(position)
{
    if (dragging)
        updateForPosition(position);
}

function mouseDownNode(node)
{
    dragging = true;
    range = null;
    updateForNode(node);
}

function mouseUpNode(node)
{
    dragging = false;
}

function mouseOverNode(node)
{
    if (dragging)
        updateForNode(node);
}

function layout()
{
    var xOffset = window.innerWidth/2 - treeView.width/2;
    var yOffset = window.innerHeight/2 - treeView.height/2;
    treeView.setCoords(xOffset,yOffset);
}

function resize(event)
{
    layout();
}

function main()
{
    var root = programmaticTree();

    var svg = DOM.createElementNS(document,SVG_NAMESPACE,"svg");
    svg.setAttribute("version","1.1");
    DOM.appendChild(document.body,svg);

    treeView = new TreeView(root);
    DOM.appendChild(svg,treeView.element);
    treeView.update();

    if (true) {
        treeView.selectionMode = TreeView.POSITION_SELECTION;
        treeView.onMouseDownPosition = mouseDownPosition;
        treeView.onMouseUpPosition = mouseUpPosition;
        treeView.onMouseOverPosition = mouseOverPosition;
    }
    else {
        treeView.onMouseDownNode = mouseDownNode;
        treeView.onMouseUpNode = mouseUpNode;
        treeView.onMouseOverNode = mouseOverNode;
    }

    UndoManager.monitorObject(state);
    window.onresize = resize;
    layout();
}


</script>
</head>

<body onload="main()" style="margin: 0">
</body>
</html>
